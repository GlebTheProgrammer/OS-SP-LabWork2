# Operating Systems and System Programming. Laboratory Work №2

### Задание

Необходимо разработать приложение на базе `Win32` с использованием языка программирования `C++`, которая вписывает в окно текстовую таблицу (`N строк` на `M столбцов`) таким образом, что все столбцы таблицы равномерно распределяются по ширине окна, а высота строк таблицы подбирается таким образом, чтобы вместить текст каждой ячейки. Также, при изменении размеров окна таблица перерасчитывается и перерисовывается.

## Решение

### Представление таблицы различных размеров с текстом 

![1](https://user-images.githubusercontent.com/55713244/195065924-14f52686-143d-457d-95ca-7e53f052b5d9.jpg)
![2](https://user-images.githubusercontent.com/55713244/195065934-9bf2f267-6eaf-4353-8c82-8b1bd46a32ef.jpg)
![3](https://user-images.githubusercontent.com/55713244/195065945-f14cd747-f142-4586-addc-2683b8d39408.jpg)

### Немного о рисовании самой таблицы

Рисование таблицы происходит в методе, который в качестве параметров получает дескриптор оконного класса, в котором необходимо нарисовать таблицу, а также заранее вычисленный размер окна.
``` C++
VOID DrawTable(HWND hWnd, RECT wndRect)
```
Для того, чтобы начать рисование, мы должны установить наальные значения для таблицы, которые указанны ниже.
``` C++
INT indent = 5, // отступ между текстом и границами ячейки (с 4-х сторон)
maxRowHight = 0, // высота ячейки
sizeOfColumn; // ширина ячейки
```
Далее, мы создаём экземпляр структуры, которая будет заниматься рисованием, после чего устанавливаем для неё начальные параметры.
``` C++
PAINTSTRUCT ps; // структура для начала рисования
// параметры: дескриптор окна, которое будет перекрашено; указатель на структуру об окрашивании
HDC hdc = BeginPaint(hWnd, &ps); // создаём идентификатор контекста отображения
RECT rect, cellForText;
HBRUSH brush;
COLORREF colorText = RGB(255, 255, 255), // цвет текста (белый)
    colorBack = RGB(30, 30, 30),   // цвет заднего фона (чёрный)
    colorLine = RGB(128, 128, 128);  // цвет линий таблицы (серый)
``` 
Далее, рисуем непосредственно фон, используя только что созданную структуру, а также производим необходиые нам расчёты для построения таблицы
``` C++
brush = CreateSolidBrush(colorBack); // создаём кисть с цветом для заднего фона
SelectObject(hdc, brush); // выбираем объект для рисования - главное окно
Rectangle(hdc, wndRect.left, wndRect.top, wndRect.right, wndRect.bottom); // рисуем прямоугольник по размеру главного окна
DeleteObject(brush); // удаляем кисть
sizeOfColumn = wndRect.right / numOfColumns; // высчитываем ширину для каждой колонки
```
Далее, происходит заполнение таблицы в цикле. Все действия описаны в комментариях
``` C++
for (int i = 0; i < numOfRows; i++)
{

    rect.top = maxRowHight; // изначально выставляем высоту ячейки в 0

    for (int j = 0; j < numOfColumns; j++)
    {

        rect.left = sizeOfColumn * j; // левая координата ячейки
        rect.right = wndRect.right / numOfColumns * (j + 1); // правая координата ячейки

        SetBkMode(hdc, TRANSPARENT); // рисуем поверх фона. Фон остаётся нетронутым
        SetTextColor(hdc, colorText); // устанавливаем цвет текста

        cellForText.top = rect.top + indent; // верхняя граница для текста
        cellForText.right = rect.right - indent;  // правая граница для текста
        cellForText.left = rect.left + indent; // левая граница для текста

        // рисуеv отформатированный текст в заданном прямоугольнике
        // параметры: дескриптор окна, текст для вывода, длина выводимого текста, размер полня форматирования, параметры вывода текста
        // ps текст выводится слева направо (ссылка на последний параметр http://vsokovikov.narod.ru/New_MSDN_API/Fonts_text/fn_drawtext.htm)
        DrawText(hdc, (LPCSTR)slist[numOfColumns * i + j], -1, &cellForText, DT_CALCRECT | DT_WORDBREAK | DT_LEFT | DT_EDITCONTROL);
        rect.right = wndRect.right / numOfColumns * (j + 1); // правая координата ячейки
        rect.bottom = cellForText.bottom + indent; // нижняя граница для текста

        DrawText(hdc, (LPCSTR)slist[numOfColumns * i + j], -1, &cellForText, DT_WORDBREAK); // отрисовка текста, сверху - настройка таблицы

        if (rect.bottom > maxRowHight) // если в ячейку занесли текст - увеличиваем высоту этой ячейки до нужного размера
            maxRowHight = rect.bottom;
    }
    //                       x1      y1            x2           y2
    DrawLine(hdc, colorLine, 0, maxRowHight, wndRect.right, maxRowHight); // рисуем горизонтальную линию
}
```
Как только мы закончили рисование части таблицы и вписывание в неё текста, дорисовываем оставшиеся линии и освобождаем объект
``` C++
DrawVerticalTableLines(hdc, colorLine, sizeOfColumn, maxRowHight); // рисуем вертикальную линию

SetBkMode(hdc, OPAQUE);  // Переустанавливаем режим фона в его состояние по умолчанию
EndPaint(hWnd, &ps);  // освобождаем объект для рисования
```
В качестве `фичи`, в программе установлено что-то наподобие часов, по значению которых в массив текстов для вписывания в таблицу помещаются строки разных размеров. Значение часов берётся из расчёта региона пользователя, обращаясь к системной функции.

### Вывод

Таким образом, было разработано приложение, позволяющее пользователю вписывать текст в таблицу и позволяющее ему `ресайзить` её так, как он хочет, при этом таблица будет автоматически подгоняться под размер оконного класса (фактически, была реализована адаптивность к любым размерам).
